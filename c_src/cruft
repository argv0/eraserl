struct data_block 
{
    data_block()
        : data_(0) {}

    data_block(const std::size_t size)
        : data_(reinterpret_cast<char *>(enif_alloc(size)))
    {
    }

    ~data_block()
    {
        enif_free(data_);
    }

    operator char*() const 
    {
        return data_;
    }
private:
    char *data_;
};



struct erasuerl_context 
{

    erasuerl_context(const size_t k, const size_t m, 
                     const size_t w, const size_t packetsize)
        : k(k), 
          m(m), 
          w(w), 
          packetsize(packetsize),
          matrix(cauchy_good_general_coding_matrix(k, m, w)),
          bitmatrix(jerasure_matrix_to_bitmatrix(k, m, w, matrix)),
          schedule(jerasure_smart_bitmatrix_to_schedule(k, m, w, bitmatrix))
    {
    }
    int k; // = 9;
    int m; // = 4;
    int w;  // = 4;
    int packetsize;
    int *matrix;
    int *bitmatrix;
    int **schedule;  
};

    void find_erasures() 
    {
        /* look for erasures in data blocks */
        int i = 0;
        ERL_NIF_TERM head, tail, list = kblocks;
        while(enif_get_list_cell(env, list, &head, &tail)) {
            ErlNifBinary bin;
            if (!enif_inspect_binary(env, head, &bin)) {
                erased[i] = 1;
                erasures[numerased] = i;
                numerased++;
            }
            else { 
                blocksize = bin.size;
                data[i] = reinterpret_cast<char *>(bin.data);
            }
            list = tail;
            i++;
        }
        /* look for erasures in coding blocks */
        list = mblocks;
        i = 0;
        while(enif_get_list_cell(env, list, &head, &tail)) {
            ErlNifBinary bin;
            if (!enif_inspect_binary(env, head, &bin)) {
                erased[h->k+i] = 1;
                erasures[numerased++] = h->k+i;
            }
            else {
                coding[i] = reinterpret_cast<char *>(bin.data);
            }
            i++;
            list = tail;
        }
        /* allocate space for recovered data/coding blocks */
        for (int i=0; i < numerased; i++) 
            if (erasures[i] < h->k) 
                data[erasures[i]] = reinterpret_cast<char *>(enif_alloc(blocksize));
            else 
                coding[erasures[i]-h->k] = reinterpret_cast<char *>(enif_alloc(blocksize));
        erasures[numerased] = -1;
    }


    /*
    ~decode_context() 
    {
        for (int i=0; i < numerased; i++) 
            if (erasures[i] < h->k) 
                enif_free(data[erasures[i]]);
            else 
                enif_free(coding[erasures[i]]);
        enif_free(data);
        enif_free(coding);
        enif_free(erased);
        enif_free(erasures);
    }
    */